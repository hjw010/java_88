 1번. 자료형
 
 /* 1. 기본 자료형(Primitive Type) : 실제값이 저장
 *    정수형 : byte(1바이트) -> short(2바이트) -> int(4바이트) -> long(8바이트)
 *    실수형 : float(4바이트) -> double(8바이트)
 *    문자형 : char(2바이트)
 *    부울형 : boolean(true/false)
 *       
 *     클래스, 인터페이스, 배열      
 * 2. 참조형(Reference Type) : 실제 객체를 가리키는 주소값 저장
 * 
 * 3. 문자열 : String 클래스 
 */
 
 ===================================
 2번. 상수
    /*
    * 상수 : 프로그램이 실행되는 동안, 값이 변하지 않는 수 또는 변경불가능한 수
    *      final 키워드는 변수에 값이 대입되고 나면, 변수값이 더이상 변경되지 않는다는 의미
    *      주로 대문자를 사용
    *      만일 값변경시 상수를 선언한 부분의 값만 변경한다. 
    * final  p305
     * 1) 변수(상수) : 변수에 값 대입불가
     * 2) 메서드 : 재정의 불가
     * 3) 클래스 : 상속 불가
    */
   final double PI = 3.14;  // 상수선언 및 초기화  .. 면접
===================================

3번. 구구단 예제
   for / while

4번. 객체 설명
    
    /*        
    *  인스턴스 생성 : 클래스명 참조변수명 = new 클래스명();    // new 생성자;
    *        접근 : 참조변수명.멤버변수
    *             참조변수명.멤버메서드;
    *  - 참조변수명에는 생성한 인스턴스의 힙메모리공간 주소값이 들어있다. 스택메모리에 생성
    *    앞의 클래스명은 데이터타입이고, 참조변수로 접근할 때 사용한다.
    *    뒤의 클래스명은 힙메모리에 인스턴스 생성시 사용되는 생성자이다.   
 
     * 클래스 : 객체에 대한 설계도, 디자인
    *       -멤버변수(속성, 필드) + 멤버메서드(기능, 동작) + 생성자
    *       
    * 클래스는 설계도(디자인)이며, 인스턴스는 이 설계도를 바탕으로 만들어진 힙메모리 공간이다.
    *        그 결과 주소값이 만들어지며, 참조변수에 할당된다.
    *        객체는 인스턴스라고도 한다.
    */ 
    
5번. setter / getter


6번. 오버로드 vs 오버라이당
	오버로드 : 매개변수가 다른 같은 이름의 메서드를 작성하는것.
	오버로딩 : 상속을 통해 메서드를 재재정의 하는것.
	
7번. static 변수 
/*[면접]
       * static 변수 = 정적변수 = 공유변수 = 클래스변수
       * static 변수 :
       * - 프로그램이 실행되어 메모리에 올라갔을 때 딱 한번 데이터영역 메모리 공간에 할당된다.
       * - 객체를 생성하지 않고, 바로 클래스명으로 접근가능하다.
       *   인스턴스마다 생성되는 변수가 아니라, 클래스에 속해 한번만 생성되는 변수이고, 여러 인스턴스가 공유하기 때문이다.
       *   인스턴스가 생성되지 않아도 사용할 수 있기 때문에 클래스명.멤버변수, 클래스명.멤버메서드 사용가능
       *   
       * - static 변수나 메서드는 static 메서드에서 호출가능
       * (정적메서드에서 인스턴스 변수나 메서드를 호출시 컴파일 오류가 난다.)
       * static 메서드는 프로그램 실행시 자동으로 메모리에 올라가나, 일반메서드는 객체를 생성해야 메모리에 올라간다.
       * 
       */



















/*  시험
       * 다형성 :  
       *        하나의 참조변수(부모)로부터 여러타입의 객체(자식)을 참조할 수 있는것.
       *        즉 부모타입의 참조변수로 자식타입의 객체를 다룰수 있는 것이 다형성.
       *        상속이 전제조건이다.
       *        
       *  - 장점 : 모든 클래스를 부모 자료형 하나로 쉽게 관리한다. 코드가 간결해진다.
       *        특히 매개변수를 부모 자료형 하나로 관리하면 코드가 간결해진다.
       *        상위 클래스에서 공통부분의 메서드를 제공하고, 하위클래스에서 추가 메소드를 구현하면 코드양도 줄어들과 유지보수도 간편하다.      
       * 
       * - 문법 : 부모타입 참조변수 = new 자식타입();
       *         큰 타입             = 작은 타입
       *         
       *         부모타입의 갯수가 자식타입의 갯수보다 적으므로 왼쪽에 부모타입이 와야 한다.
       *         다형성을 적용했을지라도 오버라이딩시 자식메서드가 호출된다.
       *         (@Override 어노테이션을 생략해도 마찬가지다.)
       *         
       * - 부모 참조변수로 접근시, 부모타입 클래스의 멤버가 힙메모리에 생성된 객체에 존재해야 한다.
       *   만약 존재하지 않으면 에러가 발생(예. readBook() )
       *   따라서 자식객체에 접근하기 위해서 다운캐스팅(다운 형변환)한다.
       *   상위클래스로는 묵시적으로 형변환이 되지만, 하위클래스로 형변환 할 때는 명시적으로 형변환한다.
       *   즉 상위클래스로 형 변환되었던 하위클래스를 다시 원래 자료형으로 형변환 하는것을 다운캐스팅이라고 한다.
       * 
       * - 다운캐스팅 : 작은타입 = (작은타입)큰타입;   // 부모가 큰 타입, 자식이 작은 타입
       *         
       * - 가상메서드 원리에 따라 move() 메서드는 힙메모리에 존재하는 실제 인스턴스의 메서드이다.
       *    오버라이딩시 자식 메서드가 호출된다.
       * 
       *  - if(부모참조변수 instanceof 자식클래스) {
       *     자식클래스 참조변수 = (자식클래스)부모참조변수;
       *      참조변수.멤버메서드();
       *    }
       *    
       *    Animal hAnimal = new Human();
       *    if(hAnimal instanceof Human) {
       *        Human human = (Human)hAnimal;
       *        human.readbook();
       *    }
       */	
       
       
       10. call by reference //메서드 호출시 매개변수에 주소 전달
       		call by value // 메서드 호출시 값을 전달  
       		
       11.추상클레스		
       /*
       * 추상이란?
       * - 여러가지 사물이나 개념으로부터 공통이 되는 특성을 파악하는 것을 말한다.
       * 
       * [면접]
       * 1. 추상클래스 => 작업명세서
       * - 하나 이상의 추상메서드를 가지고 있는 클래스를 의미한다.
       * - abstract 키워드를 이용하여 구현되지 않는 추상메서드를 기술할 수 있다.
       * - 자식클래스에게 구현을 위임하고자 할 때 사용되며, 프로그램의 확장성을 취해 많이 사용하는 설계방법이다.
       * - 추상클래스는 일반메서드, 추상메서드 모두 올 수 있다.
       * - 전제조건은 반드시 상속을 해야 한다.
       * - 다형성 적용 가능하다.
       * 
       * - 문법 : public abstract class 클래스명 {
       *             public abstract 반환형 메서드명();  // 추상메서드
       *       }
       * 
       * 2. 추상메서드
       * - 하위클래스가 어떤 클래스냐에 따라 구현코드가 달라지며, 하위클래스에 구현을 위임하는 것이다.
       * - 미완성되어있는 메서드이며, 몸체가 없는 메서드로서 항상 세미콜론(;)으로 종료되어야 한다.
       * 
       *  3. 추상클래스의 상속
       *  - 추상클래스를 상속받은 자식클래스는 추상메서드를 반드시 재정의(Override) 해야 하며,
       *    재정의하지 않으면 컴파일 오류가 발생한다.
       *  - 자식클래스에게 강제성과 통일성을 줄 수 있다.(협업시 작업명세서)  
       *       
       * 4. 추상클래스의 객체 생성
       * - 추상클래스는 객체를 생성할 수 없으며(추상 메서드 때문), 상속 계층에서
       *   추상적인 개념을 나타내기 위한 용도로 사용한다.
       * - 상속을 통하여 자식클래스에서 추상메서드를 구현하고, 자식클래스 객체를 생성하여 메서드를 접근할 수 있다.  
       * 
       */
       
       12.인터페이스
       ./*
    * [면접] 추상클래스 vs 인터페이스
    *       인터페이스 설명
    *       
    *  인터페이스 
    *  - 기능정의서(표준 작업명세서)이다. - 강제성과 통일성
    *  - 설계(선언)와 구현을 분리시키는 것을 가능하게 한다.
    *    (설계 : 인터페이스, 구현 : 자식클래스)
    *  - 객체생성 불가능하며, 객체 Type으로 가능하다.(다형성 적용)
    *  - 인터페이스의 멤버는 상수(static final 생략 가능), 추상메서드(abstract 생략 가능)만 올수 있다.
    *  - 단 static 메서드, 디폴트 메서드, private 메서드는 예외(JDK 1.8부터)
    *  - 인터페이스를 implements(=구현)할 자식클래스에서 추상메서드를 재정의한다.
    *  
    *  1. 인터페이스 작성
    *  interface 인터페이스명 {
    *     // 상수
    *     public static final 데이터타입 대문자상수명 = 값;
    *      // 추상메서드
    *      public 반환형 추상메서드(매개변수1,...);  // body없다
    *  }
    *  
    *  2. 인터페이스 구현
    *  class 클래스명 implements 인터페이스명{
    *     @Override
    *      public 반환형 추상메서드(매개변수1,...) {
    *          // 인터페이스에 정의된 추상메서드를 구현해야 한다.
    *       }
    *  }
    * 
    * 3. 인터페이스는 다중 상속 가능    cf) 클래스는 단일 상속만 가능
    * interface 인터페이스명  extends  인터페이스명1, .. 인터페이스명n {
    * 
    * }
    * 
    * class 클래스명  extends  클래스명1, .. 클래스명n {  //NG - 클래스는 단일 상속만 가능
    * }
    * 
    * 4. 상속과 구현을 동시
    * class 클래스명 extends 부모클래스 implements 인터페이스명1, .. 인터페이스명n {
    * 
    * }
    * 
    */
    
    13.컬렉션 프레임워크
    /*
       * 컬렉션 프레임워크
       * 
       * Collection 인터페이스
       * - List 인터페이스 : 클래스 종류는 ArrayList, Vector, LinkedList
       * - Set 인터페이스 : 클래스종류는 HashSet, TreeSet
       * - Map 인터페이스 : 클래스종류는 HashMap, HashTable, TreeMap
       * 
       *  <면접>
       *  1. 특징
       *  List 인터페이스 : 순서가 있는 자료관리, 중복허용한다.
       *                 index를 사용하여 요소에 접근한다.
       *                 리스트에 들어있는 요소들의 인덱스는 0부터 시작한다.
       *                 클래스종류는 ArrayList, Vector, LinkedList
       *                 
       *  Set 인터페이스 : 순서가 없는 자료관리, 중복허용 않는다.
       *                클래스종류는 HashSet, TreeSet
       *                
       * [ArrayList]
       * 2. 선언           
       * ArrayList<데이터타입클래스> 참조변수 = new ArrayList<데이터타입클래스>();
       * 
       * 다형성 적용
       * List<데이터타입클래스> 참조변수 = new ArrayList<데이터타입클래스>();
       *
       * 3. 특징 : 데이터 순서가 있고, 중복허용된다.
       * 4. 추가 : list.add(값);   // 앞에서부터 순서대로 추가
       *         list.add(추가할 위치 index, 값);  // 지정한 인덱스에 값을 추가, 그 뒤값은 밀려난다.
       *         
       * 5. 값 가져오기 : list.get(가져올 index);  // list.size() 만큼 반복    
       * 6. 교체 : list.set(교체할 위치 index, 값);  // 지정한 인덱스의 값을 변경.. 그 뒤값은 그대로이다.
       * 7. 삭제 : list.remove(삭제할 위치 index);
       * 8. 검색 : list.indexOf(검색할 값);  // 중요
       *          리스트에서 검색할 값과 똑같은 값을 갖는 첫번째 데이터를 찾아서 그 위치의 인덱스를 리턴한다.
       *          검색할 값과 일치한 데이터가 없으면 -1을 리턴한다.
       * 9. 전체 삭제 : list.clear();
       * 10. 반복자 : Iterator<E> iterator : while(hasNext()) { next() }          
       */
       
       
       14.hashMap
       /*
	 * p439
	 * 해싱(hashing) : 키를 이용해서 해시테이블로 부터 데이터를 가져오는 과정
	 * 
	 * hashMap
	 * 1) 특징
	 * -데이터의 순서를 보장하지 않는다.
	 * -key와 value 쌍으로 저장한다.
	 * -key는 중복될 수 없다.
	 * -key를 이용해서 value를 가져올 수 있다.
	 * -List 와 달리 index가 없다.
	 * -Map이라는 인터페이스를 구현한 클래스이다.
	 * 
	 * 2) 선언
	 * -HashMap<key 타입, value 타입> map = HashMap<key 타입, value 타입>();
	 * -Map<key 타입, value 타입> map = HashMap<key 타입, value 타입>();
	 * 
	 * 3) 메서드
	 * - 데이터 추가 : put(key,value);
	 * - 데이터 가져오기 : get(key);
	 * - 데이터 삭제 : remove(key);
	 * - 데이터 비어있는지 여부 : isEmpty();
	 * - 해당 키가 있는지 여부 : containsKey(key);
	 * - 해당 값이 있는지 여부 : containsValue(value);
	 * - 해당 갯수 : size();
	 * 
	 * 
	 */
	 
	 15.Generic
	 	/*
	 * [면접]
	 * 제네릭 : 여러 참조 자료형이 쓰일 수 있는 곳에 특정한 자료형을 지정하지않고
	 * 			제네릭 클레스의 인스턴스 생성시점에 어떤 자료형을 사용할 것인지 지정하는 방식
	 * 			T의 자료형이 결정되는 시점보다 빨리 생성되는 static맴버에서는 사용 못함.
	 * 			T : type
	 * 			E : element
	 * 			K : key
	 * 			V : value
	 * 
	 *  - 제네릭으로 구현하면 형변환을 하지 않아도됨(매개변수 다형성, 다운캐스팅을 안해도 된다.)
	 *  -> 제네릭 클래스를 사용하면 컴파일러는 일단 대입된 자료형이 잘 쓰였는지 확인.
	 *  	class 파일을 생성할때 T를 사용한 곳에 지정된 자료형에 따라 컴파일하므로
	 */
	 
	 
	 
	 
	 16. Thread
	 
	 /*
		 * [면접] Thread 생성과 실행 (1) Thread 클레스를 상속하기
		 * 
		 * 1.Thread 클레스를 상속받아서 클레스를 작성한다. 
		 * 2.run()메서드 재정의한다. 
		 * 3.main() 메서드에서 Thread 객체
		 * 생성한다. 
		 * 4.start() 메서드를 호출해서 스레드를 실행한다(run()을 호출하는게 아님). 
		 * 5.run() 메서드가 실행된다.
		 * 
		 */
		 
		 /*
		 * [면접] Thread 생성과 실행 
		 * (2) Runnable 인터페이스 구현
		 * 
		 * 1.Runnable 인터페이스 구현하여 클레스를 작성한다. 
		 * 2.추상메서드 run()을 재정의
		 * 3.main() 메서드에서 Thread 객체를 생성하고, 이때 구현한 클레스 객체를 매개변수로 전달
		 * 4.start() 메서드를 호출해서 스레드를 실행한다(run()을 호출하는게 아님). 
		 * 5.run() 메서드가 실행된다.
		 * 
		 */